# name       : profiling_slow.patch
# introduced : 11 or before
# maintainer : Yasufumi
#
#!!! notice !!!
# Any small change to this file in the main branch
# should be done or reviewed by the maintainer!
diff -ruN /dev/null b/patch_info/profiling_slow.info
--- /dev/null	1970-01-01 09:00:00.000000000 +0900
+++ b/patch_info/profiling_slow.info	2010-12-02 19:23:07.768064078 +0900
@@ -0,0 +1,9 @@
+File=profiling_slow.info
+Name=profiling from SHOW PROFILE to slow.log
+Version=1.0
+Author=Percona <info@percona.com>
+License=GPL
+Comment=
+Changelog
+2009-05-18
+Initial implementation
diff -ruN a/sql/log.cc b/sql/log.cc
--- a/sql/log.cc	2010-11-03 07:01:14.000000000 +0900
+++ b/sql/log.cc	2010-12-02 19:28:31.337989417 +0900
@@ -2600,6 +2600,11 @@
                     (ulong) thd->sent_row_count,
                     (ulong) thd->examined_row_count) == (uint) -1)
       tmp_errno= errno;
+
+#if defined(ENABLED_PROFILING) && defined(COMMUNITY_SERVER)
+    thd->profiling.print_current(&log_file);
+#endif
+
     if (thd->db && strcmp(thd->db, db))
     {						// Database changed
       if (my_b_printf(&log_file,"use %s;\n",thd->db) == (uint) -1)
diff -ruN a/sql/sql_class.h b/sql/sql_class.h
--- a/sql/sql_class.h	2010-11-03 07:01:14.000000000 +0900
+++ b/sql/sql_class.h	2010-12-02 20:14:36.335072621 +0900
@@ -446,6 +446,8 @@
   ulong optimizer_search_depth;
   ulong preload_buff_size;
   ulong profiling_history_size;
+  my_bool profiling_server;
+  my_bool profiling_use_getrusage;
   ulong read_buff_size;
   ulong read_rnd_buff_size;
   ulong div_precincrement;
diff -ruN a/sql/sql_profile.cc b/sql/sql_profile.cc
--- a/sql/sql_profile.cc	2010-11-03 07:01:14.000000000 +0900
+++ b/sql/sql_profile.cc	2010-12-02 20:26:35.448357413 +0900
@@ -243,7 +243,8 @@
 {
   time_usecs= (double) my_getsystime() / 10.0;  /* 1 sec was 1e7, now is 1e6 */
 #ifdef HAVE_GETRUSAGE
-  getrusage(RUSAGE_SELF, &rusage);
+  if ((profile->get_profiling())->enabled_getrusage())
+    getrusage(RUSAGE_SELF, &rusage);
 #elif defined(_WIN32)
   FILETIME ftDummy;
   // NOTE: Get{Process|Thread}Times has a granularity of the clock interval,
@@ -251,6 +252,19 @@
   // measurable by this function.
   GetProcessTimes(GetCurrentProcess(), &ftDummy, &ftDummy, &ftKernel, &ftUser);
 #endif
+
+#ifdef HAVE_CLOCK_GETTIME
+  struct timespec tp;
+
+  if (!(clock_gettime(CLOCK_THREAD_CPUTIME_ID, &tp)))
+  {
+    cpu_time_usecs= tp.tv_sec*1000000000.0 + tp.tv_nsec;
+  }
+  else
+#endif
+  {
+    cpu_time_usecs= 0;
+  }
 }
 
 
@@ -366,7 +380,7 @@
     finish_current_query();
   }
 
-  enabled= ((thd->variables.option_bits & OPTION_PROFILING) != 0);
+  enabled= ((thd->variables.option_bits & OPTION_PROFILING) != 0) || ( thd->variables.profiling_server );
 
   if (! enabled) DBUG_VOID_RETURN;
 
@@ -404,7 +418,8 @@
     status_change("ending", NULL, NULL, 0);
 
     if ((enabled) &&                                    /* ON at start? */
-        ((thd->variables.option_bits & OPTION_PROFILING) != 0) &&   /* and ON at end? */
+        (((thd->variables.option_bits & OPTION_PROFILING) != 0) ||
+          (thd->variables.profiling_server)) &&   /* and ON at end? */
         (current->query_source != NULL) &&
         (! current->entries.is_empty()))
     {
@@ -505,6 +520,118 @@
   DBUG_VOID_RETURN;
 }
 
+bool PROFILING::enabled_getrusage()
+{
+  return thd->variables.profiling_use_getrusage;
+}
+
+/**
+   For a given profile entry specified by a name and 2 time measurements,
+   print its normalized name (i.e. with all spaces replaced with underscores)
+   along with its wall clock and CPU time.
+*/
+
+static void my_b_print_status(IO_CACHE *log_file, const char *status,
+                              PROF_MEASUREMENT *start, PROF_MEASUREMENT *stop)
+{
+  DBUG_ENTER("my_b_print_status");
+  DBUG_ASSERT(log_file != NULL && status != NULL);
+  char query_time_buff[22+7];
+  const char *tmp;
+
+  my_b_printf(log_file, "Profile_");
+  for (tmp= status; *tmp; tmp++)
+    my_b_write_byte(log_file, *tmp == ' ' ? '_' : *tmp);
+
+  snprintf(query_time_buff, sizeof(query_time_buff), "%.6f",
+           (stop->time_usecs - start->time_usecs) / (1000.0 * 1000));
+  my_b_printf(log_file, ": %s ", query_time_buff);
+
+  my_b_printf(log_file, "Profile_");
+  for (tmp= status; *tmp; tmp++)
+    my_b_write_byte(log_file, *tmp == ' ' ? '_' : *tmp);
+  my_b_printf(log_file, "_cpu: ");
+
+  snprintf(query_time_buff, sizeof(query_time_buff), "%.6f",
+           (stop->cpu_time_usecs - start->cpu_time_usecs) /
+           (1000.0 * 1000 * 1000));
+  my_b_printf(log_file, "%s ", query_time_buff);
+
+  DBUG_VOID_RETURN;
+}
+
+/**
+  Print output for current query to file 
+*/
+
+int PROFILING::print_current(IO_CACHE *log_file)
+{
+  DBUG_ENTER("PROFILING::print_current");
+  ulonglong row_number= 0;
+
+  QUERY_PROFILE *query;
+  /* Get current query */
+  if (current == NULL)
+  {
+    DBUG_RETURN(0);
+  }
+
+  query= current;
+
+  my_b_printf(log_file, "# ");
+
+    void *entry_iterator;
+    PROF_MEASUREMENT *entry, *previous= NULL, *first= NULL;
+    /* ...and for each query, go through all its state-change steps. */
+    for (entry_iterator= query->entries.new_iterator();
+         entry_iterator != NULL;
+         entry_iterator= query->entries.iterator_next(entry_iterator),
+         previous=entry, row_number++)
+    {
+      entry= query->entries.iterator_value(entry_iterator);
+
+      /* Skip the first.  We count spans of fence, not fence-posts. */
+      if (previous == NULL) {first= entry; continue;}
+
+      if (thd->lex->sql_command == SQLCOM_SHOW_PROFILE)
+      {
+        /*
+          We got here via a SHOW command.  That means that we stored
+          information about the query we wish to show and that isn't
+          in a WHERE clause at a higher level to filter out rows we
+          wish to exclude.
+
+          Because that functionality isn't available in the server yet,
+          we must filter here, at the wrong level.  Once one can con-
+          struct where and having conditions at the SQL layer, then this
+          condition should be ripped out.
+        */
+        if (thd->lex->profile_query_id == 0) /* 0 == show final query */
+        {
+          if (query != last)
+            continue;
+        }
+        else
+        {
+          if (thd->lex->profile_query_id != query->profiling_query_id)
+            continue;
+        }
+      }
+
+      my_b_print_status(log_file, previous->status, previous, entry);
+    }
+
+    my_b_write_byte(log_file, '\n');
+    if ((entry != NULL) && (first != NULL))
+    {
+      my_b_printf(log_file, "# ");
+      my_b_print_status(log_file, "total", first, entry);
+      my_b_write_byte(log_file, '\n');
+    }
+
+  DBUG_RETURN(0);
+}
+
 /**
   Fill the information schema table, "query_profile", as defined in show.cc .
   There are two ways to get to this function:  Selecting from the information
diff -ruN a/sql/sql_profile.h b/sql/sql_profile.h
--- a/sql/sql_profile.h	2010-11-03 07:01:14.000000000 +0900
+++ b/sql/sql_profile.h	2010-12-02 19:23:07.823955510 +0900
@@ -164,11 +164,15 @@
 */
 class PROF_MEASUREMENT
 {
-private:
-  friend class QUERY_PROFILE;
-  friend class PROFILING;
-
   QUERY_PROFILE *profile;
+
+  char *allocated_status_memory;
+
+  void set_label(const char *status_arg, const char *function_arg, 
+                  const char *file_arg, unsigned int line_arg);
+  void clean_up();
+
+public:
   char *status;
 #ifdef HAVE_GETRUSAGE
   struct rusage rusage;
@@ -181,12 +185,7 @@
   unsigned int line;
 
   double time_usecs;
-  char *allocated_status_memory;
-
-  void set_label(const char *status_arg, const char *function_arg, 
-                  const char *file_arg, unsigned int line_arg);
-  void clean_up();
-  
+  double cpu_time_usecs;
   PROF_MEASUREMENT();
   PROF_MEASUREMENT(QUERY_PROFILE *profile_arg, const char *status_arg);
   PROF_MEASUREMENT(QUERY_PROFILE *profile_arg, const char *status_arg,
@@ -231,6 +230,11 @@
 
   /* Show this profile.  This is called by PROFILING. */
   bool show(uint options);
+
+public:
+
+  inline PROFILING * get_profiling() { return profiling; };
+
 };
 
 
@@ -276,9 +280,11 @@
 
   /* SHOW PROFILES */
   bool show_profiles();
+  bool enabled_getrusage();
 
   /* ... from INFORMATION_SCHEMA.PROFILING ... */
   int fill_statistics_info(THD *thd, TABLE_LIST *tables, Item *cond);
+  int print_current(IO_CACHE *log_file);
 };
 
 #  endif /* HAVE_PROFILING */
diff -ruN a/sql/sys_vars.cc b/sql/sys_vars.cc
--- a/sql/sys_vars.cc	2010-11-03 07:01:14.000000000 +0900
+++ b/sql/sys_vars.cc	2010-12-02 20:19:19.907356956 +0900
@@ -2390,6 +2390,16 @@
        "profiling_history_size", "Limit of query profiling memory",
        SESSION_VAR(profiling_history_size), CMD_LINE(REQUIRED_ARG),
        VALID_RANGE(0, 100), DEFAULT(15), BLOCK_SIZE(1));
+
+static Sys_var_mybool Sys_profiling_server(
+       "profiling_server", "Enable profiling of all threads",
+       SESSION_VAR(profiling_server), CMD_LINE(OPT_ARG),
+       DEFAULT(FALSE));
+
+static Sys_var_mybool Sys_profiling_use_getrusage(
+       "profiling_use_getrusage", "Enable getrusage function call for profiling",
+       SESSION_VAR(profiling_use_getrusage), CMD_LINE(OPT_ARG),
+       DEFAULT(FALSE));
 #endif
 
 static Sys_var_harows Sys_select_limit(
