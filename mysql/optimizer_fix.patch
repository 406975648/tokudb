diff -r 718833fc9273 patch_info/optimizer_fix.info
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/patch_info/optimizer_fix.info	Fri Feb 19 20:39:22 2010 -0800
@@ -0,0 +1,8 @@
+File=optimizer_fix.patch
+Name=Unofficial optimizer fixes
+Version=1.0
+Author=Percona <info@percona.com>
+License=GPL
+Comment=
+2010-01
+Ported to 5.1.42
diff -r 718833fc9273 sql/mysql_priv.h
--- a/sql/mysql_priv.h	Fri Feb 19 20:38:44 2010 -0800
+++ b/sql/mysql_priv.h	Fri Feb 19 20:39:22 2010 -0800
@@ -2098,6 +2098,7 @@
 extern ulong slave_exec_mode_options;
 extern my_bool opt_readonly, lower_case_file_system;
 extern my_bool opt_userstat_running, opt_thread_statistics;
+extern my_bool opt_optimizer_fix;
 extern my_bool opt_enable_named_pipe, opt_sync_frm, opt_allow_suspicious_udfs;
 extern my_bool opt_secure_auth;
 extern char* opt_secure_file_priv;
diff -r 718833fc9273 sql/mysqld.cc
--- a/sql/mysqld.cc	Fri Feb 19 20:38:44 2010 -0800
+++ b/sql/mysqld.cc	Fri Feb 19 20:39:22 2010 -0800
@@ -495,6 +495,7 @@
 #endif /* defined(ENABLED_DEBUG_SYNC) */
 my_bool opt_old_style_user_limits= 0, trust_function_creators= 0;
 my_bool opt_userstat_running= 0, opt_thread_statistics= 0;
+my_bool opt_optimizer_fix= 0;
 /*
   True if there is at least one per-hour limit for some user, so we should
   check them before each query (and possibly reset counters when hour is
@@ -5776,6 +5777,7 @@
   OPT_SLOW_QUERY_LOG_FILE,
   OPT_USERSTAT_RUNNING,
   OPT_THREAD_STATISTICS,
+  OPT_OPTIMIZER_FIX,
   OPT_USE_GLOBAL_LONG_QUERY_TIME,
   OPT_IGNORE_BUILTIN_INNODB,
   OPT_BINLOG_DIRECT_NON_TRANS_UPDATE,
@@ -7166,6 +7168,10 @@
    "Control TABLE_STATISTICS running, when userstat_running is enabled",
    (uchar**) &opt_thread_statistics, (uchar**) &opt_thread_statistics,
    0, GET_BOOL, NO_ARG, 0, 0, 1, 0, 1, 0},
+  {"optimizer_fix", OPT_OPTIMIZER_FIX,
+   "Enable unofficial optimizer fixes.",
+   (uchar**) &opt_optimizer_fix, (uchar**) &opt_optimizer_fix,
+   0, GET_BOOL, NO_ARG, 0, 0, 1, 0, 1, 0},
   {"binlog-direct-non-transactional-updates", OPT_BINLOG_DIRECT_NON_TRANS_UPDATE,
    "Causes updates to non-transactional engines using statement format to be written directly to binary log. Before using this option make sure that there are no dependencies between transactional and non-transactional tables such as in the statement INSERT INTO t_myisam SELECT * FROM t_innodb; otherwise, slaves may diverge from the master.",
    (uchar**) &global_system_variables.binlog_direct_non_trans_update, (uchar**) &max_system_variables.binlog_direct_non_trans_update, 0, GET_BOOL, NO_ARG, 0,
diff -r 718833fc9273 sql/opt_range.cc
--- a/sql/opt_range.cc	Fri Feb 19 20:38:44 2010 -0800
+++ b/sql/opt_range.cc	Fri Feb 19 20:39:22 2010 -0800
@@ -695,7 +695,7 @@
 static TRP_RANGE *get_key_scans_params(PARAM *param, SEL_TREE *tree,
                                        bool index_read_must_be_used,
                                        bool update_tbl_stats,
-                                       double read_time);
+                                       double read_time, ha_rows *estimated_records);
 static
 TRP_ROR_INTERSECT *get_best_ror_intersect(const PARAM *param, SEL_TREE *tree,
                                           double read_time,
@@ -2206,6 +2206,7 @@
 				  ha_rows limit, bool force_quick_range)
 {
   uint idx;
+  ha_rows estimated_records=0;
   double scan_time;
   DBUG_ENTER("SQL_SELECT::test_quick_select");
   DBUG_PRINT("enter",("keys_to_use: %lu  prev_tables: %lu  const_tables: %lu",
@@ -2376,12 +2377,17 @@
 
         /* Get best 'range' plan and prepare data for making other plans */
         if ((range_trp= get_key_scans_params(&param, tree, FALSE, TRUE,
-                                             best_read_time)))
+                                             best_read_time, &estimated_records)))
         {
           best_trp= range_trp;
           best_read_time= best_trp->read_cost;
         }
 
+        if (opt_optimizer_fix && estimated_records)
+        {
+          records = estimated_records;
+        }
+
         /*
           Simultaneous key scans and row deletes on several handler
           objects are not allowed so don't use ROR-intersection for
@@ -3732,7 +3738,7 @@
   {
     DBUG_EXECUTE("info", print_sel_tree(param, *ptree, &(*ptree)->keys_map,
                                         "tree in SEL_IMERGE"););
-    if (!(*cur_child= get_key_scans_params(param, *ptree, TRUE, FALSE, read_time)))
+    if (!(*cur_child= get_key_scans_params(param, *ptree, TRUE, FALSE, read_time, NULL)))
     {
       /*
         One of index scans in this index_merge is more expensive than entire
@@ -4835,11 +4841,12 @@
 static TRP_RANGE *get_key_scans_params(PARAM *param, SEL_TREE *tree,
                                        bool index_read_must_be_used, 
                                        bool update_tbl_stats,
-                                       double read_time)
+                                       double read_time, ha_rows *estimated_records)
 {
   int idx;
   SEL_ARG **key,**end, **key_to_read= NULL;
   ha_rows UNINIT_VAR(best_records);              /* protected by key_to_read */
+  ha_rows min_records= HA_POS_ERROR;
   TRP_RANGE* read_plan= NULL;
   bool pk_is_clustered= param->table->file->primary_key_is_clustered();
   DBUG_ENTER("get_key_scans_params");
@@ -4910,6 +4917,11 @@
         key_to_read=  key;
       }
 
+      if (estimated_records && found_records
+          && min_records > found_records)
+      {
+        min_records = found_records;
+      }
     }
   }
 
@@ -4932,6 +4944,12 @@
   else
     DBUG_PRINT("info", ("No 'range' table read plan found"));
 
+  /* minimum number of records (not 0) as estimated number of records */
+  if (estimated_records && min_records != HA_POS_ERROR)
+  {
+    *estimated_records = min_records;
+  }
+
   DBUG_RETURN(read_plan);
 }
 
diff -r 718833fc9273 sql/set_var.cc
--- a/sql/set_var.cc	Fri Feb 19 20:38:44 2010 -0800
+++ b/sql/set_var.cc	Fri Feb 19 20:39:22 2010 -0800
@@ -494,6 +494,8 @@
 						     &opt_userstat_running);
 static sys_var_bool_ptr		sys_thread_statistics(&vars, "thread_statistics",
 						      &opt_thread_statistics);
+static sys_var_bool_ptr		sys_optimizer_fix(&vars, "optimizer_fix",
+						  &opt_optimizer_fix);
 static sys_var_thd_ulong	sys_read_rnd_buff_size(&vars, "read_rnd_buffer_size",
 					       &SV::read_rnd_buff_size);
 static sys_var_thd_ulong	sys_div_precincrement(&vars, "div_precision_increment",
diff -r 718833fc9273 sql/sql_select.cc
--- a/sql/sql_select.cc	Fri Feb 19 20:38:44 2010 -0800
+++ b/sql/sql_select.cc	Fri Feb 19 20:39:22 2010 -0800
@@ -2511,6 +2511,11 @@
       table->reginfo.impossible_range=1;
       DBUG_RETURN(0);
     }
+    if (opt_optimizer_fix && error == 0)
+    {
+      /* quick select is not effective. but the estimated value is used. */
+      DBUG_RETURN(select->records);
+    }
     DBUG_PRINT("warning",("Couldn't use record count on const keypart"));
   }
   DBUG_RETURN(HA_POS_ERROR);			/* This shouldn't happend */
@@ -4305,6 +4310,9 @@
                 (keyinfo->key_length+table->file->ref_length)+1;
               tmp= record_count*(tmp+keys_per_block-1)/keys_per_block;
             }
+            else if (opt_optimizer_fix)
+              tmp= table->file->read_time(key, (uint)min(record_count,(double)UINT_MAX),
+                                          (ha_rows)(record_count * min(tmp,s->worst_seeks)));
             else
               tmp= record_count*min(tmp,s->worst_seeks);
           }
@@ -4472,6 +4480,9 @@
                 (keyinfo->key_length+table->file->ref_length)+1;
               tmp= record_count*(tmp+keys_per_block-1)/keys_per_block;
             }
+            else if (opt_optimizer_fix)
+              tmp= table->file->read_time(key, (uint)min(record_count,(double)UINT_MAX),
+                                          (ha_rows)(record_count * min(tmp,s->worst_seeks)));
             else
               tmp= record_count*min(tmp,s->worst_seeks);
           }
