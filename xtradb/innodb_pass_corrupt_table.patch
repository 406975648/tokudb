diff -ruN innodb_plugin-1.0.6_orig/btr/btr0btr.c innodb_plugin-1.0.6_tmp/btr/btr0btr.c
--- innodb_plugin-1.0.6_orig/btr/btr0btr.c	2009-11-19 22:01:00.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/btr/btr0btr.c	2010-03-01 11:56:29.000000000 +0900
@@ -137,6 +137,12 @@
 	root_page_no = dict_index_get_page(index);
 
 	block = btr_block_get(space, zip_size, root_page_no, RW_X_LATCH, mtr);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(0);
+	}
+	ut_a(block);
+
 	ut_a((ibool)!!page_is_comp(buf_block_get_frame(block))
 	     == dict_table_is_comp(index->table));
 #ifdef UNIV_BTR_DEBUG
@@ -422,6 +428,12 @@
 
 	root = btr_root_get(index, &mtr);
 
+	if (srv_pass_corrupt_table && !root) {
+		mtr_commit(&mtr);
+		return(0);
+	}
+	ut_a(root);
+
 	if (flag == BTR_N_LEAF_PAGES) {
 		seg_header = root + PAGE_HEADER + PAGE_BTR_SEG_LEAF;
 
@@ -862,6 +874,13 @@
 	mtr_start(&mtr);
 
 	root = btr_page_get(space, zip_size, root_page_no, RW_X_LATCH, &mtr);
+
+	if (srv_pass_corrupt_table && !root) {
+		mtr_commit(&mtr);
+		return;
+	}
+	ut_a(root);
+	
 #ifdef UNIV_BTR_DEBUG
 	ut_a(btr_root_fseg_validate(FIL_PAGE_DATA + PAGE_BTR_SEG_LEAF
 				    + root, space));
@@ -884,6 +903,12 @@
 	mtr_start(&mtr);
 
 	root = btr_page_get(space, zip_size, root_page_no, RW_X_LATCH, &mtr);
+
+	if (srv_pass_corrupt_table && !root) {
+		mtr_commit(&mtr);
+		return;
+	}
+	ut_a(root);
 #ifdef UNIV_BTR_DEBUG
 	ut_a(btr_root_fseg_validate(FIL_PAGE_DATA + PAGE_BTR_SEG_TOP
 				    + root, space));
@@ -917,6 +942,11 @@
 
 	block = btr_block_get(space, zip_size, root_page_no, RW_X_LATCH, mtr);
 
+	if (srv_pass_corrupt_table && !block) {
+		return;
+	}
+	ut_a(block);
+
 	btr_search_drop_page_hash_index(block);
 
 	header = buf_block_get_frame(block) + PAGE_HEADER + PAGE_BTR_SEG_TOP;
diff -ruN innodb_plugin-1.0.6_orig/btr/btr0cur.c innodb_plugin-1.0.6_tmp/btr/btr0cur.c
--- innodb_plugin-1.0.6_orig/btr/btr0cur.c	2010-03-01 11:55:52.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/btr/btr0cur.c	2010-03-01 11:56:29.000000000 +0900
@@ -227,6 +227,11 @@
 	case BTR_MODIFY_LEAF:
 		mode = latch_mode == BTR_SEARCH_LEAF ? RW_S_LATCH : RW_X_LATCH;
 		get_block = btr_block_get(space, zip_size, page_no, mode, mtr);
+
+		if (srv_pass_corrupt_table && !get_block) {
+			return;
+		}
+		ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 		ut_a(page_is_comp(get_block->frame) == page_is_comp(page));
 #endif /* UNIV_BTR_DEBUG */
@@ -240,6 +245,11 @@
 			get_block = btr_block_get(space, zip_size,
 						  left_page_no,
 						  RW_X_LATCH, mtr);
+
+			if (srv_pass_corrupt_table && !get_block) {
+				return;
+			}
+			ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 			ut_a(page_is_comp(get_block->frame)
 			     == page_is_comp(page));
@@ -251,6 +261,11 @@
 
 		get_block = btr_block_get(space, zip_size, page_no,
 					  RW_X_LATCH, mtr);
+
+		if (srv_pass_corrupt_table && !get_block) {
+			return;
+		}
+		ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 		ut_a(page_is_comp(get_block->frame) == page_is_comp(page));
 #endif /* UNIV_BTR_DEBUG */
@@ -262,6 +277,11 @@
 			get_block = btr_block_get(space, zip_size,
 						  right_page_no,
 						  RW_X_LATCH, mtr);
+
+			if (srv_pass_corrupt_table && !get_block) {
+				return;
+			}
+			ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 			ut_a(page_is_comp(get_block->frame)
 			     == page_is_comp(page));
@@ -283,6 +303,11 @@
 			get_block = btr_block_get(space, zip_size,
 						  left_page_no, mode, mtr);
 			cursor->left_block = get_block;
+
+			if (srv_pass_corrupt_table && !get_block) {
+				return;
+			}
+			ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 			ut_a(page_is_comp(get_block->frame)
 			     == page_is_comp(page));
@@ -293,6 +318,11 @@
 		}
 
 		get_block = btr_block_get(space, zip_size, page_no, mode, mtr);
+
+		if (srv_pass_corrupt_table && !get_block) {
+			return;
+		}
+		ut_a(get_block);
 #ifdef UNIV_BTR_DEBUG
 		ut_a(page_is_comp(get_block->frame) == page_is_comp(page));
 #endif /* UNIV_BTR_DEBUG */
@@ -522,6 +552,16 @@
 					 rw_latch, guess, buf_mode,
 					 __FILE__, __LINE__, mtr);
 		if (block == NULL) {
+			if (srv_pass_corrupt_table && buf_mode != BUF_GET_IF_IN_POOL) {
+				page_cursor->block = 0;
+				page_cursor->rec = 0;
+				if (estimate) {
+					cursor->path_arr->nth_rec = ULINT_UNDEFINED;
+				}
+				break;
+			}
+			ut_a(buf_mode == BUF_GET_IF_IN_POOL);
+
 			/* This must be a search to perform an insert;
 			try insert to the insert buffer */
 
@@ -549,6 +589,16 @@
 
 		page = buf_block_get_frame(block);
 
+		if (srv_pass_corrupt_table && !page) {
+			page_cursor->block = 0;
+			page_cursor->rec = 0;
+			if (estimate) {
+				cursor->path_arr->nth_rec = ULINT_UNDEFINED;
+			}
+			break;
+		}
+		ut_a(page);
+
 		block->check_index_page_at_flush = TRUE;
 
 		if (rw_latch != RW_NO_LATCH) {
@@ -730,6 +780,17 @@
 					 RW_NO_LATCH, NULL, BUF_GET,
 					 __FILE__, __LINE__, mtr);
 		page = buf_block_get_frame(block);
+
+		if (srv_pass_corrupt_table && !page) {
+			page_cursor->block = 0;
+			page_cursor->rec = 0;
+			if (estimate) {
+				cursor->path_arr->nth_rec = ULINT_UNDEFINED;
+			}
+			break;
+		}
+		ut_a(page);
+
 		ut_ad(0 == ut_dulint_cmp(index->id,
 					 btr_page_get_index_id(page)));
 
@@ -849,6 +910,14 @@
 					 RW_NO_LATCH, NULL, BUF_GET,
 					 __FILE__, __LINE__, mtr);
 		page = buf_block_get_frame(block);
+
+		if (srv_pass_corrupt_table && !page) {
+			page_cursor->block = 0;
+			page_cursor->rec = 0;
+			break;
+		}
+		ut_a(page);
+
 		ut_ad(0 == ut_dulint_cmp(index->id,
 					 btr_page_get_index_id(page)));
 
@@ -1166,6 +1235,12 @@
 	*big_rec = NULL;
 
 	block = btr_cur_get_block(cursor);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(DB_CORRUPTION);
+	}
+	ut_a(block);
+
 	page = buf_block_get_frame(block);
 	index = cursor->index;
 	zip_size = buf_block_get_zip_size(block);
@@ -2912,6 +2987,11 @@
 
 	block = btr_cur_get_block(cursor);
 
+	if (srv_pass_corrupt_table && !block) {
+		return(DB_CORRUPTION);
+	}
+	ut_a(block);
+
 	ut_ad(page_is_leaf(buf_block_get_frame(block)));
 
 	rec = btr_cur_get_rec(cursor);
@@ -3555,6 +3635,11 @@
 
 		page = btr_cur_get_page(&cursor);
 
+		if (srv_pass_corrupt_table && !page) {
+			break;
+		}
+		ut_a(page);
+
 		supremum = page_get_supremum_rec(page);
 		if (stats_method == SRV_STATS_METHOD_IGNORE_NULLS && is_first_page) {
 			/* the cursor should be the first record of the page. */
diff -ruN innodb_plugin-1.0.6_orig/btr/btr0pcur.c innodb_plugin-1.0.6_tmp/btr/btr0pcur.c
--- innodb_plugin-1.0.6_orig/btr/btr0pcur.c	2009-05-25 19:52:29.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/btr/btr0pcur.c	2010-03-01 11:56:29.000000000 +0900
@@ -32,7 +32,7 @@
 #include "ut0byte.h"
 #include "rem0cmp.h"
 #include "trx0trx.h"
-
+#include "srv0srv.h"
 /**************************************************************//**
 Allocates memory for a persistent cursor object and initializes the cursor.
 @return	own: persistent cursor */
@@ -102,6 +102,12 @@
 	ut_ad(cursor->latch_mode != BTR_NO_LATCHES);
 
 	block = btr_pcur_get_block(cursor);
+
+	if (srv_pass_corrupt_table && !block) {
+		return;
+	}
+	ut_a(block);
+
 	index = btr_cur_get_index(btr_pcur_get_btr_cur(cursor));
 
 	page_cursor = btr_pcur_get_page_cur(cursor);
@@ -413,6 +419,15 @@
 	next_block = btr_block_get(space, zip_size, next_page_no,
 				   cursor->latch_mode, mtr);
 	next_page = buf_block_get_frame(next_block);
+
+	if (srv_pass_corrupt_table && !next_page) {
+		btr_leaf_page_release(btr_pcur_get_block(cursor),
+				      cursor->latch_mode, mtr);
+		btr_pcur_get_page_cur(cursor)->block = 0;
+		btr_pcur_get_page_cur(cursor)->rec = 0;
+		return;
+	}
+	ut_a(next_page);
 #ifdef UNIV_BTR_DEBUG
 	ut_a(page_is_comp(next_page) == page_is_comp(page));
 	ut_a(btr_page_get_prev(next_page, mtr)
diff -ruN innodb_plugin-1.0.6_orig/btr/btr0sea.c innodb_plugin-1.0.6_tmp/btr/btr0sea.c
--- innodb_plugin-1.0.6_orig/btr/btr0sea.c	2010-03-01 11:55:52.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/btr/btr0sea.c	2010-03-01 11:56:29.000000000 +0900
@@ -42,7 +42,7 @@
 #include "btr0pcur.h"
 #include "btr0btr.h"
 #include "ha0ha.h"
-
+#include "srv0srv.h"
 /** Flag: has the search system been enabled?
 Protected by btr_search_latch and btr_search_enabled_mutex. */
 UNIV_INTERN char		btr_search_enabled	= TRUE;
@@ -585,6 +585,11 @@
 
 	block = btr_cur_get_block(cursor);
 
+	if (srv_pass_corrupt_table && !block) {
+		return;
+	}
+	ut_a(block);
+
 	/* NOTE that the following two function calls do NOT protect
 	info or block->n_fields etc. with any semaphore, to save CPU time!
 	We cannot assume the fields are consistent when we return from
diff -ruN innodb_plugin-1.0.6_orig/buf/buf0buf.c innodb_plugin-1.0.6_tmp/buf/buf0buf.c
--- innodb_plugin-1.0.6_orig/buf/buf0buf.c	2010-03-01 11:55:53.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/buf/buf0buf.c	2010-03-01 11:56:29.000000000 +0900
@@ -52,6 +52,7 @@
 #include "log0recv.h"
 #include "page0zip.h"
 #include "trx0trx.h"
+#include "srv0start.h"
 
 /* prototypes for new functions added to ha_innodb.cc */
 trx_t* innobase_get_trx();
@@ -1809,6 +1810,14 @@
 		return(NULL);
 	}
 
+	if (srv_pass_corrupt_table) {
+		if (bpage->is_corrupt) {
+			rw_lock_s_unlock(&page_hash_latch);
+			return(NULL);
+		}
+	}
+	ut_a(!(bpage->is_corrupt));
+
 	block_mutex = buf_page_get_mutex_enter(bpage);
 
 	rw_lock_s_unlock(&page_hash_latch);
@@ -2246,6 +2255,14 @@
 		return(NULL);
 	}
 
+	if (srv_pass_corrupt_table) {
+		if (block->page.is_corrupt) {
+			mutex_exit(block_mutex);
+			return(NULL);
+		}
+	}
+	ut_a(!(block->page.is_corrupt));
+
 	switch (buf_block_get_state(block)) {
 		buf_page_t*	bpage;
 		ibool		success;
@@ -2874,6 +2891,7 @@
 	bpage->newest_modification = 0;
 	bpage->oldest_modification = 0;
 	HASH_INVALIDATE(bpage, hash);
+	bpage->is_corrupt = FALSE;
 #ifdef UNIV_DEBUG_FILE_ACCESSES
 	bpage->file_page_was_freed = FALSE;
 #endif /* UNIV_DEBUG_FILE_ACCESSES */
@@ -3329,7 +3347,8 @@
 void
 buf_page_io_complete(
 /*=================*/
-	buf_page_t*	bpage)	/*!< in: pointer to the block in question */
+	buf_page_t*	bpage,	/*!< in: pointer to the block in question */
+	trx_t*		trx)
 {
 	enum buf_io_fix	io_type;
 	const ibool	uncompressed = (buf_page_get_state(bpage)
@@ -3406,6 +3425,7 @@
 				(ulong) bpage->offset);
 		}
 
+		if (!srv_pass_corrupt_table || !bpage->is_corrupt) {
 		/* From version 3.23.38 up we store the page checksum
 		to the 4 first bytes of the page end lsn field */
 
@@ -3447,6 +3467,19 @@
 			      REFMAN "forcing-recovery.html\n"
 			      "InnoDB: about forcing recovery.\n", stderr);
 
+			if (srv_pass_corrupt_table && bpage->space > 0
+			    && bpage->space < SRV_LOG_SPACE_FIRST_ID) {
+				fprintf(stderr,
+					"InnoDB: space %lu will be treated as corrupt.\n",
+					bpage->space);
+				fil_space_set_corrupt(bpage->space);
+				if (trx && trx->dict_operation_lock_mode == 0) {
+					dict_table_set_corrupt_by_space(bpage->space, TRUE);
+				} else {
+					dict_table_set_corrupt_by_space(bpage->space, FALSE);
+				}
+				bpage->is_corrupt = TRUE;
+			} else
 			if (srv_force_recovery < SRV_FORCE_IGNORE_CORRUPT) {
 				fputs("InnoDB: Ending processing because of"
 				      " a corrupt database page.\n",
@@ -3454,6 +3487,7 @@
 				exit(1);
 			}
 		}
+		} /**/
 
 		if (recv_recovery_is_on()) {
 			/* Pages must be uncompressed for crash recovery. */
@@ -3463,8 +3497,11 @@
 
 		if (uncompressed && !recv_no_ibuf_operations) {
 			ibuf_merge_or_delete_for_page(
+				/* Delete possible entries, if bpage is_corrupt */
+				(srv_pass_corrupt_table && bpage->is_corrupt) ? NULL :
 				(buf_block_t*) bpage, bpage->space,
 				bpage->offset, buf_page_get_zip_size(bpage),
+				(srv_pass_corrupt_table && bpage->is_corrupt) ? FALSE :
 				TRUE);
 		}
 	}
diff -ruN innodb_plugin-1.0.6_orig/buf/buf0rea.c innodb_plugin-1.0.6_tmp/buf/buf0rea.c
--- innodb_plugin-1.0.6_orig/buf/buf0rea.c	2010-03-01 11:55:53.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/buf/buf0rea.c	2010-03-01 11:56:29.000000000 +0900
@@ -187,12 +187,19 @@
 			      sync, space, 0, offset, 0, UNIV_PAGE_SIZE,
 			      ((buf_block_t*) bpage)->frame, bpage, trx);
 	}
+
+	if (srv_pass_corrupt_table) {
+		if (*err != DB_SUCCESS) {
+			bpage->is_corrupt = TRUE;
+		}
+	} else {
 	ut_a(*err == DB_SUCCESS);
+	}
 
 	if (sync) {
 		/* The i/o is already completed when we arrive from
 		fil_read */
-		buf_page_io_complete(bpage);
+		buf_page_io_complete(bpage, trx);
 	}
 
 	return(1);
diff -ruN innodb_plugin-1.0.6_orig/dict/dict0dict.c innodb_plugin-1.0.6_tmp/dict/dict0dict.c
--- innodb_plugin-1.0.6_orig/dict/dict0dict.c	2010-03-01 11:55:53.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/dict/dict0dict.c	2010-03-01 11:56:29.000000000 +0900
@@ -54,6 +54,7 @@
 #include "row0merge.h"
 #include "m_ctype.h" /* my_isspace() */
 #include "ha_prototypes.h" /* innobase_strcasecmp() */
+#include "srv0start.h" /* SRV_LOG_SPACE_FIRST_ID */
 
 #include <ctype.h>
 
@@ -658,7 +659,7 @@
 	mutex_exit(&(dict_sys->mutex));
 
 	if (table != NULL) {
-		if (!table->stat_initialized) {
+		if (!table->stat_initialized && !table->is_corrupt) {
 			/* If table->ibd_file_missing == TRUE, this will
 			print an error message and return without doing
 			anything. */
@@ -1181,7 +1182,7 @@
 		    + dict_sys->size) > srv_dict_size_limit ) {
 		prev_table = UT_LIST_GET_PREV(table_LRU, table);
 
-		if (table == self || table->n_mysql_handles_opened)
+		if (table == self || table->n_mysql_handles_opened || table->is_corrupt)
 			goto next_loop;
 
 		cached_foreign_tables = 0;
@@ -4219,6 +4220,11 @@
 	}
 
 	while (index) {
+		if (table->is_corrupt) {
+			ut_a(srv_pass_corrupt_table);
+			return;
+		}
+
 		size = btr_get_size(index, BTR_TOTAL_SIZE);
 
 		index->stat_index_size = size;
@@ -4920,4 +4926,42 @@
 	mem_free(dict_sys);
 	dict_sys = NULL;
 }
+
+/*************************************************************************
+set is_corrupt flag by space_id*/
+
+void
+dict_table_set_corrupt_by_space(
+/*============================*/
+	ulint	space_id,
+	ibool	need_mutex)
+{
+	dict_table_t*	table;
+	ibool		found = FALSE;
+
+	ut_a(space_id != 0 && space_id < SRV_LOG_SPACE_FIRST_ID);
+
+	if (need_mutex)
+		mutex_enter(&(dict_sys->mutex));
+
+	table = UT_LIST_GET_FIRST(dict_sys->table_LRU);
+
+	while (table) {
+		if (table->space == space_id) {
+			table->is_corrupt = TRUE;
+			found = TRUE;
+		}
+
+		table = UT_LIST_GET_NEXT(table_LRU, table);
+	}
+
+	if (need_mutex)
+		mutex_exit(&(dict_sys->mutex));
+
+	if (!found) {
+		fprintf(stderr, "InnoDB: space to be marked as "
+			"crashed was not found for id %lu.\n",
+			(ulong) space_id);
+	}
+}
 #endif /* !UNIV_HOTBACKUP */
diff -ruN innodb_plugin-1.0.6_orig/dict/dict0mem.c innodb_plugin-1.0.6_tmp/dict/dict0mem.c
--- innodb_plugin-1.0.6_orig/dict/dict0mem.c	2009-07-20 16:29:14.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/dict/dict0mem.c	2010-03-01 11:56:29.000000000 +0900
@@ -85,6 +85,8 @@
 	/* The number of transactions that are either waiting on the
 	AUTOINC lock or have been granted the lock. */
 	table->n_waiting_or_granted_auto_inc_locks = 0;
+
+	table->is_corrupt = FALSE;
 #endif /* !UNIV_HOTBACKUP */
 
 	ut_d(table->magic_n = DICT_TABLE_MAGIC_N);
diff -ruN innodb_plugin-1.0.6_orig/fil/fil0fil.c innodb_plugin-1.0.6_tmp/fil/fil0fil.c
--- innodb_plugin-1.0.6_orig/fil/fil0fil.c	2010-03-01 11:55:53.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/fil/fil0fil.c	2010-03-01 11:56:29.000000000 +0900
@@ -220,6 +220,7 @@
 				file we have written to */
 	ibool		is_in_unflushed_spaces; /*!< TRUE if this space is
 				currently in unflushed_spaces */
+	ibool		is_corrupt;
 	UT_LIST_NODE_T(fil_space_t) space_list;
 				/*!< list of all spaces */
 	ulint		magic_n;/*!< FIL_SPACE_MAGIC_N */
@@ -1220,6 +1221,8 @@
 		    ut_fold_string(name), space);
 	space->is_in_unflushed_spaces = FALSE;
 
+	space->is_corrupt = FALSE;
+
 	UT_LIST_ADD_LAST(space_list, fil_system->space_list, space);
 
 	mutex_exit(&fil_system->mutex);
@@ -4711,6 +4714,22 @@
 	ut_a(byte_offset % OS_FILE_LOG_BLOCK_SIZE == 0);
 	ut_a((len % OS_FILE_LOG_BLOCK_SIZE) == 0);
 
+	if (srv_pass_corrupt_table && space->is_corrupt) {
+		/* should ignore i/o for the crashed space */
+		mutex_enter(&fil_system->mutex);
+		fil_node_complete_io(node, fil_system, type);
+		mutex_exit(&fil_system->mutex);
+		if (mode == OS_AIO_NORMAL) {
+			ut_a(space->purpose == FIL_TABLESPACE);
+			buf_page_io_complete(message, trx);
+		}
+		if (type == OS_FILE_READ) {
+			return(DB_TABLESPACE_DELETED);
+		} else {
+			return(DB_SUCCESS);
+		}
+	} else {
+		ut_a(!space->is_corrupt);
 #ifdef UNIV_HOTBACKUP
 	/* In ibbackup do normal i/o, not aio */
 	if (type == OS_FILE_READ) {
@@ -4725,6 +4744,8 @@
 	ret = os_aio(type, mode | wake_later, node->name, node->handle, buf,
 		     offset_low, offset_high, len, node, message, trx);
 #endif
+	} /**/
+
 	ut_a(ret);
 
 	if (mode == OS_AIO_SYNC) {
@@ -4871,7 +4892,7 @@
 
 	if (fil_node->space->purpose == FIL_TABLESPACE) {
 		srv_set_io_thread_op_info(segment, "complete io for buf page");
-		buf_page_io_complete(message);
+		buf_page_io_complete(message, NULL);
 	} else {
 		srv_set_io_thread_op_info(segment, "complete io for log");
 		log_io_complete(message);
@@ -5223,3 +5244,46 @@
                return 0;
        }
 }
+
+/*************************************************************************
+functions to access is_corrupt flag of fil_space_t*/
+
+ibool
+fil_space_is_corrupt(
+/*=================*/
+	ulint	space_id)
+{
+	fil_space_t*	space;
+	ibool		ret = FALSE;
+
+	mutex_enter(&fil_system->mutex);
+
+	space = fil_space_get_by_id(space_id);
+
+	if (space && space->is_corrupt) {
+		ret = TRUE;
+	}
+
+	mutex_exit(&fil_system->mutex);
+
+	return(ret);
+}
+
+void
+fil_space_set_corrupt(
+/*==================*/
+	ulint	space_id)
+{
+	fil_space_t*	space;
+
+	mutex_enter(&fil_system->mutex);
+
+	space = fil_space_get_by_id(space_id);
+
+	if (space) {
+		space->is_corrupt = TRUE;
+	}
+
+	mutex_exit(&fil_system->mutex);
+}
+
diff -ruN innodb_plugin-1.0.6_orig/fsp/fsp0fsp.c innodb_plugin-1.0.6_tmp/fsp/fsp0fsp.c
--- innodb_plugin-1.0.6_orig/fsp/fsp0fsp.c	2009-10-01 20:24:33.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/fsp/fsp0fsp.c	2010-03-01 11:56:29.000000000 +0900
@@ -370,6 +370,12 @@
 	ut_ad(id || !zip_size);
 
 	block = buf_page_get(id, zip_size, 0, RW_X_LATCH, mtr);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(0);
+	}
+	ut_a(block);
+
 	header = FSP_HEADER_OFFSET + buf_block_get_frame(block);
 	buf_block_dbg_add_level(block, SYNC_FSP_PAGE);
 
@@ -788,6 +794,12 @@
 	fsp_header_t*	sp_header;
 
 	block = buf_page_get(space, zip_size, 0, RW_X_LATCH, mtr);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(0);
+	}
+	ut_a(block);
+
 	buf_block_dbg_add_level(block, SYNC_FSP_PAGE);
 
 	sp_header = FSP_HEADER_OFFSET + buf_block_get_frame(block);
@@ -1871,6 +1883,11 @@
 {
 	fseg_inode_t*	inode;
 
+	if (srv_pass_corrupt_table && !page) {
+		return(ULINT_UNDEFINED);
+	}
+	ut_a(page);
+
 	for (; i < FSP_SEG_INODES_PER_PAGE(zip_size); i++) {
 
 		inode = fsp_seg_inode_page_get_nth_inode(
@@ -1984,6 +2001,11 @@
 
 	page = buf_block_get_frame(block);
 
+	if (srv_pass_corrupt_table && !page) {
+		return(0);
+	}
+	ut_a(page);
+
 	n = fsp_seg_inode_page_find_free(page, 0, zip_size, mtr);
 
 	ut_a(n != ULINT_UNDEFINED);
@@ -2077,6 +2099,11 @@
 
 	inode = fut_get_ptr(space, zip_size, inode_addr, RW_X_LATCH, mtr);
 
+	if (srv_pass_corrupt_table && !inode) {
+		return(0);
+	}
+	ut_a(inode);
+
 	if (UNIV_UNLIKELY
 	    (ut_dulint_is_zero(mach_read_from_8(inode + FSEG_ID)))) {
 
@@ -2104,7 +2131,7 @@
 {
 	fseg_inode_t*	inode
 		= fseg_inode_try_get(header, space, zip_size, mtr);
-	ut_a(inode);
+	ut_a(srv_pass_corrupt_table || inode);
 	return(inode);
 }
 
@@ -3263,6 +3290,11 @@
 
 	descr = xdes_get_descriptor(space, zip_size, page, mtr);
 
+	if (srv_pass_corrupt_table && !descr) {
+		/* The page may be corrupt. pass it. */
+		return;
+	}
+
 	ut_a(descr);
 	if (xdes_get_bit(descr, XDES_FREE_BIT, page % FSP_EXTENT_SIZE, mtr)) {
 		fputs("InnoDB: Dump of the tablespace extent descriptor: ",
@@ -3515,6 +3547,11 @@
 
 	descr = xdes_get_descriptor(space, zip_size, header_page, mtr);
 
+	if (srv_pass_corrupt_table && !descr) {
+		/* The page may be corrupt. pass it. */
+		return(TRUE);
+	}
+
 	/* Check that the header resides on a page which has not been
 	freed yet */
 
@@ -3599,6 +3636,12 @@
 
 	inode = fseg_inode_get(header, space, zip_size, mtr);
 
+	if (srv_pass_corrupt_table && !inode) {
+		/* ignore the corruption */
+		return(TRUE);
+	}
+	ut_a(inode);
+
 	descr = fseg_get_first_extent(inode, space, zip_size, mtr);
 
 	if (descr != NULL) {
diff -ruN innodb_plugin-1.0.6_orig/handler/ha_innodb.cc innodb_plugin-1.0.6_tmp/handler/ha_innodb.cc
--- innodb_plugin-1.0.6_orig/handler/ha_innodb.cc	2010-03-01 11:55:53.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/handler/ha_innodb.cc	2010-03-01 11:56:29.000000000 +0900
@@ -3380,6 +3380,12 @@
 		DBUG_RETURN(1);
 	}
 
+	if (share->ib_table && share->ib_table->is_corrupt) {
+		free_share(share);
+
+		DBUG_RETURN(HA_ERR_CRASHED_ON_USAGE);
+	}
+
 	/* Create buffers for packing the fields of a record. Why
 	table->reclength did not work here? Obviously, because char
 	fields when packed actually became 1 byte longer, when we also
@@ -3407,6 +3413,19 @@
 	/* Get pointer to a table object in InnoDB dictionary cache */
 	ib_table = dict_table_get(norm_name, TRUE);
 	
+	if (ib_table && ib_table->is_corrupt) {
+		free_share(share);
+		my_free(upd_buff, MYF(0));
+
+		DBUG_RETURN(HA_ERR_CRASHED_ON_USAGE);
+	}
+
+	if (share->ib_table) {
+		ut_a(share->ib_table == ib_table);
+	} else {
+		share->ib_table = ib_table;
+	}
+
 	if (NULL == ib_table) {
 		if (is_part && retries < 10) {
 			++retries;
@@ -4573,6 +4592,10 @@
 
 	ha_statistic_increment(&SSV::ha_write_count);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	if (table->timestamp_field_type & TIMESTAMP_AUTO_SET_ON_INSERT)
 		table->timestamp_field->set_time();
 
@@ -4779,6 +4802,10 @@
 func_exit:
 	innobase_active_small();
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	DBUG_RETURN(error_result);
 }
 
@@ -4955,6 +4982,10 @@
 
 	ha_statistic_increment(&SSV::ha_update_count);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	if (table->timestamp_field_type & TIMESTAMP_AUTO_SET_ON_UPDATE)
 		table->timestamp_field->set_time();
 
@@ -5044,6 +5075,10 @@
 
 	innobase_active_small();
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	DBUG_RETURN(error);
 }
 
@@ -5065,6 +5100,10 @@
 
 	ha_statistic_increment(&SSV::ha_delete_count);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	if (!prebuilt->upd_node) {
 		row_get_prebuilt_update_vector(prebuilt);
 	}
@@ -5091,6 +5130,10 @@
 
 	innobase_active_small();
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	DBUG_RETURN(error);
 }
 
@@ -5330,6 +5373,10 @@
 
 	ha_statistic_increment(&SSV::ha_read_key_count);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	index = prebuilt->index;
 
 	if (UNIV_UNLIKELY(index == NULL)) {
@@ -5392,6 +5439,10 @@
 		ret = DB_UNSUPPORTED;
 	}
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	switch (ret) {
 	case DB_SUCCESS:
 		error = 0;
@@ -5486,6 +5537,10 @@
 {
 	DBUG_ENTER("change_active_index");
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	ut_ad(user_thd == ha_thd());
 	ut_a(prebuilt->trx == thd_to_trx(user_thd));
 
@@ -5576,6 +5631,10 @@
 
 	DBUG_ENTER("general_fetch");
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	ut_a(prebuilt->trx == thd_to_trx(user_thd));
 
 	innodb_srv_conc_enter_innodb(prebuilt->trx);
@@ -5585,6 +5644,10 @@
 
 	innodb_srv_conc_exit_innodb(prebuilt->trx);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	switch (ret) {
 	case DB_SUCCESS:
 		error = 0;
@@ -6811,6 +6874,10 @@
 		DBUG_RETURN(my_errno=HA_ERR_WRONG_COMMAND);
 	}
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	/* Truncate the table in InnoDB */
 
 	error = row_truncate_table_for_mysql(prebuilt->table, prebuilt->trx);
@@ -6819,6 +6886,10 @@
 		goto fallback;
 	}
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	error = convert_error_code_to_mysql(error, prebuilt->table->flags,
 					    NULL);
 
@@ -7320,6 +7391,16 @@
 	return(ranges + (double) rows / (double) total_rows * time_for_scan);
 }
 
+UNIV_INTERN
+bool
+ha_innobase::is_corrupt() const
+{
+	if (share->ib_table)
+		return ((bool)share->ib_table->is_corrupt);
+	else
+		return (FALSE);
+}
+
 /*********************************************************************//**
 Returns statistics information of the table to the MySQL interpreter,
 in various fields of the handle object. */
@@ -7370,9 +7451,9 @@
 	ib_table = prebuilt->table;
 
 	if (flag & HA_STATUS_TIME) {
-		if (innobase_stats_on_metadata
-		    || thd_sql_command(user_thd) == SQLCOM_ANALYZE
-		    ) {
+		if ((innobase_stats_on_metadata
+		     || thd_sql_command(user_thd) == SQLCOM_ANALYZE)
+		    && !share->ib_table->is_corrupt) {
 			/* In sql_show we call with this flag: update
 			then statistics so that they are up-to-date */
 
@@ -7599,6 +7680,10 @@
 	THD*		thd,		/*!< in: connection thread handle */
 	HA_CHECK_OPT*	check_opt)	/*!< in: currently ignored */
 {
+	if (share->ib_table->is_corrupt) {
+		return(HA_ADMIN_CORRUPT);
+	}
+
 	/* Serialize ANALYZE TABLE inside InnoDB, see
 	Bug#38996 Race condition in ANALYZE TABLE */
 	pthread_mutex_lock(&analyze_mutex);
@@ -7608,6 +7693,10 @@
 
 	pthread_mutex_unlock(&analyze_mutex);
 
+	if (share->ib_table->is_corrupt) {
+		return(HA_ADMIN_CORRUPT);
+	}
+
 	return(0);
 }
 
@@ -7653,6 +7742,10 @@
 
 	ret = row_check_table_for_mysql(prebuilt);
 
+	if (ret != DB_INTERRUPTED && share->ib_table->is_corrupt) {
+		return(HA_ADMIN_CORRUPT);
+	}
+
 	switch (ret) {
 	case DB_SUCCESS:
 		return(HA_ADMIN_OK);
@@ -8386,6 +8479,10 @@
 
 	update_thd(thd);
 
+	if (share->ib_table->is_corrupt) {
+		DBUG_RETURN(HA_ERR_CRASHED);
+	}
+
 	if (prebuilt->table->ibd_file_missing && !thd_tablespace_op(thd)) {
 		ut_print_timestamp(stderr);
 		fprintf(stderr,
@@ -10670,6 +10767,14 @@
   "Relax limitation of column size at table creation as builtin InnoDB.",
   NULL, NULL, 0, 0, 1, 0);
 
+static	MYSQL_SYSVAR_ULONG(pass_corrupt_table, srv_pass_corrupt_table,
+  PLUGIN_VAR_RQCMDARG,
+  "Pass corruptions of user tables as 'corrupt table' instead of not crashing itself, "
+  "when used with file_per_table. "
+  "All file io for the datafile after detected as corrupt are disabled, "
+  "except for the deletion.",
+  NULL, NULL, 0, 0, 1, 0);
+
 static struct st_mysql_sys_var* innobase_system_variables[]= {
   MYSQL_SYSVAR(additional_mem_pool_size),
   MYSQL_SYSVAR(autoextend_increment),
@@ -10749,6 +10854,7 @@
   MYSQL_SYSVAR(io_capacity),
   MYSQL_SYSVAR(use_purge_thread),
   MYSQL_SYSVAR(relax_table_creation),
+  MYSQL_SYSVAR(pass_corrupt_table),
   NULL
 };
 
diff -ruN innodb_plugin-1.0.6_orig/handler/ha_innodb.h innodb_plugin-1.0.6_tmp/handler/ha_innodb.h
--- innodb_plugin-1.0.6_orig/handler/ha_innodb.h	2009-11-12 00:53:20.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/handler/ha_innodb.h	2010-03-01 11:56:29.000000000 +0900
@@ -36,6 +36,7 @@
 					incremented in get_share()
 					and decremented in free_share() */
 	void*		table_name_hash;/*!< hash table chain node */
+	dict_table_t*	ib_table;
 } INNOBASE_SHARE;
 
 
@@ -119,6 +120,7 @@
 	int close(void);
 	double scan_time();
 	double read_time(uint index, uint ranges, ha_rows rows);
+	bool is_corrupt() const;
 
 	int write_row(uchar * buf);
 	int update_row(const uchar * old_data, uchar * new_data);
diff -ruN innodb_plugin-1.0.6_orig/handler/innodb_patch_info.h innodb_plugin-1.0.6_tmp/handler/innodb_patch_info.h
--- innodb_plugin-1.0.6_orig/handler/innodb_patch_info.h	2010-03-01 11:55:53.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/handler/innodb_patch_info.h	2010-03-01 12:12:06.000000000 +0900
@@ -43,5 +43,6 @@
 {"innodb_extend_slow","Extended statistics in slow.log","It is InnoDB-part only. It needs to patch also to mysqld.","http://www.percona.com/docs/wiki/percona-xtradb"},
 {"innodb_relax_table_creation","Relax limitation of column size at table creation as builtin InnoDB.","","http://www.percona.com/docs/wiki/percona-xtradb"},
 {"innodb_lru_dump_restore","Dump and restore command for content of buffer pool","","http://www.percona.com/docs/wiki/percona-xtradb"},
+{"innodb_pass_corrupt_table","Treat tables as corrupt instead of crash, when meet corrupt blocks","","http://www.percona.com/docs/wiki/percona-xtradb"},
 {NULL, NULL, NULL, NULL}
 };
diff -ruN innodb_plugin-1.0.6_orig/include/btr0btr.ic innodb_plugin-1.0.6_tmp/include/btr0btr.ic
--- innodb_plugin-1.0.6_orig/include/btr0btr.ic	2009-05-26 22:28:49.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/include/btr0btr.ic	2010-03-01 11:56:29.000000000 +0900
@@ -28,7 +28,7 @@
 #include "mtr0mtr.h"
 #include "mtr0log.h"
 #include "page0zip.h"
-
+#include "srv0srv.h"
 #define BTR_MAX_NODE_LEVEL	50	/*!< Maximum B-tree page level
 					(not really a hard limit).
 					Used in debug assertions
@@ -52,7 +52,9 @@
 
 	block = buf_page_get(space, zip_size, page_no, mode, mtr);
 
-	if (mode != RW_NO_LATCH) {
+	ut_a(srv_pass_corrupt_table || block);
+
+	if (block && mode != RW_NO_LATCH) {
 
 		buf_block_dbg_add_level(block, SYNC_TREE_NODE);
 	}
diff -ruN innodb_plugin-1.0.6_orig/include/buf0buf.h innodb_plugin-1.0.6_tmp/include/buf0buf.h
--- innodb_plugin-1.0.6_orig/include/buf0buf.h	2010-03-01 11:55:52.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/include/buf0buf.h	2010-03-01 11:56:29.000000000 +0900
@@ -855,7 +855,7 @@
 	const buf_block_t*	block)	/*!< in: pointer to the control block */
 	__attribute__((pure));
 #else /* UNIV_DEBUG */
-# define buf_block_get_frame(block) (block)->frame
+# define buf_block_get_frame(block) (block ? (block)->frame : 0)
 #endif /* UNIV_DEBUG */
 /*********************************************************************//**
 Gets the space id of a block.
@@ -987,7 +987,8 @@
 void
 buf_page_io_complete(
 /*=================*/
-	buf_page_t*	bpage);	/*!< in: pointer to the block in question */
+	buf_page_t*	bpage,	/*!< in: pointer to the block in question */
+	trx_t*		trx);
 /********************************************************************//**
 Calculates a folded value of a file page address to use in the page hash
 table.
@@ -1155,6 +1156,7 @@
 					0 if the block was never accessed
 					in the buffer pool */
 	/* @} */
+	ibool		is_corrupt;
 # ifdef UNIV_DEBUG_FILE_ACCESSES
 	ibool		file_page_was_freed;
 					/*!< this is set to TRUE when fsp
diff -ruN innodb_plugin-1.0.6_orig/include/buf0buf.ic innodb_plugin-1.0.6_tmp/include/buf0buf.ic
--- innodb_plugin-1.0.6_orig/include/buf0buf.ic	2010-03-01 11:55:52.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/include/buf0buf.ic	2010-03-01 11:56:29.000000000 +0900
@@ -35,7 +35,7 @@
 #include "buf0flu.h"
 #include "buf0lru.h"
 #include "buf0rea.h"
-
+#include "srv0srv.h"
 /********************************************************************//**
 Reads the freed_page_clock of a buffer block.
 @return	freed_page_clock */
@@ -581,6 +581,12 @@
 /*================*/
 	const buf_block_t*	block)	/*!< in: pointer to the control block */
 {
+	ut_a(srv_pass_corrupt_table || block);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(0);
+	}
+
 	ut_ad(block);
 
 	switch (buf_block_get_state(block)) {
diff -ruN innodb_plugin-1.0.6_orig/include/dict0dict.h innodb_plugin-1.0.6_tmp/include/dict0dict.h
--- innodb_plugin-1.0.6_orig/include/dict0dict.h	2010-03-01 11:55:52.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/include/dict0dict.h	2010-03-01 11:56:29.000000000 +0900
@@ -1164,6 +1164,15 @@
 dict_close(void);
 /*============*/
 
+/*************************************************************************
+set is_corrupt flag by space_id*/
+
+void
+dict_table_set_corrupt_by_space(
+/*============================*/
+	ulint	space_id,
+	ibool	need_mutex);
+
 #ifndef UNIV_NONINL
 #include "dict0dict.ic"
 #endif
diff -ruN innodb_plugin-1.0.6_orig/include/dict0mem.h innodb_plugin-1.0.6_tmp/include/dict0mem.h
--- innodb_plugin-1.0.6_orig/include/dict0mem.h	2009-08-07 08:04:03.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/include/dict0mem.h	2010-03-01 11:56:29.000000000 +0900
@@ -521,6 +521,7 @@
 				the AUTOINC lock on this table. */
 				/* @} */
 	/*----------------------*/
+	ibool		is_corrupt;
 #endif /* !UNIV_HOTBACKUP */
 
 #ifdef UNIV_DEBUG
diff -ruN innodb_plugin-1.0.6_orig/include/fil0fil.h innodb_plugin-1.0.6_tmp/include/fil0fil.h
--- innodb_plugin-1.0.6_orig/include/fil0fil.h	2010-03-01 11:55:53.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/include/fil0fil.h	2010-03-01 11:56:29.000000000 +0900
@@ -748,6 +748,19 @@
 fil_system_hash_nodes(void);
 /*========================*/
 
+/*************************************************************************
+functions to access is_corrupt flag of fil_space_t*/
+
+ibool
+fil_space_is_corrupt(
+/*=================*/
+	ulint	space_id);
+
+void
+fil_space_set_corrupt(
+/*==================*/
+	ulint	space_id);
+
 typedef	struct fil_space_struct	fil_space_t;
 
 #endif
diff -ruN innodb_plugin-1.0.6_orig/include/fut0fut.ic innodb_plugin-1.0.6_tmp/include/fut0fut.ic
--- innodb_plugin-1.0.6_orig/include/fut0fut.ic	2009-05-25 19:52:29.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/include/fut0fut.ic	2010-03-01 11:56:29.000000000 +0900
@@ -23,6 +23,7 @@
 Created 12/13/1995 Heikki Tuuri
 ***********************************************************************/
 
+#include "srv0srv.h"
 #include "sync0rw.h"
 #include "buf0buf.h"
 
@@ -48,6 +49,12 @@
 	ut_ad((rw_latch == RW_S_LATCH) || (rw_latch == RW_X_LATCH));
 
 	block = buf_page_get(space, zip_size, addr.page, rw_latch, mtr);
+
+	if (srv_pass_corrupt_table && !block) {
+		return(0);
+	}
+	ut_a(block);
+
 	ptr = buf_block_get_frame(block) + addr.boffset;
 
 	buf_block_dbg_add_level(block, SYNC_NO_ORDER_CHECK);
diff -ruN innodb_plugin-1.0.6_orig/include/srv0srv.h innodb_plugin-1.0.6_tmp/include/srv0srv.h
--- innodb_plugin-1.0.6_orig/include/srv0srv.h	2010-03-01 11:55:53.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/include/srv0srv.h	2010-03-01 11:56:29.000000000 +0900
@@ -247,6 +247,7 @@
 
 extern ulint	srv_expand_import;
 extern ulint	srv_relax_table_creation;
+extern ulint	srv_pass_corrupt_table;
 
 extern ulint	srv_extra_rsegments;
 extern ulint	srv_dict_size_limit;
diff -ruN innodb_plugin-1.0.6_orig/row/row0ins.c innodb_plugin-1.0.6_tmp/row/row0ins.c
--- innodb_plugin-1.0.6_orig/row/row0ins.c	2009-10-26 22:46:18.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/row/row0ins.c	2010-03-01 11:56:29.000000000 +0900
@@ -1340,6 +1340,12 @@
 		const rec_t*		rec = btr_pcur_get_rec(&pcur);
 		const buf_block_t*	block = btr_pcur_get_block(&pcur);
 
+		if (srv_pass_corrupt_table && !block) {
+			err = DB_CORRUPTION;
+			break;
+		}
+		ut_a(block);
+
 		if (page_rec_is_infimum(rec)) {
 
 			goto next_rec;
diff -ruN innodb_plugin-1.0.6_orig/row/row0merge.c innodb_plugin-1.0.6_tmp/row/row0merge.c
--- innodb_plugin-1.0.6_orig/row/row0merge.c	2009-11-12 22:49:08.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/row/row0merge.c	2010-03-01 11:56:29.000000000 +0900
@@ -1216,6 +1216,13 @@
 
 		if (UNIV_LIKELY(has_next)) {
 			rec = btr_pcur_get_rec(&pcur);
+
+			if (srv_pass_corrupt_table && !rec) {
+				err = DB_CORRUPTION;
+				goto err_exit;
+			}
+			ut_a(rec);
+
 			offsets = rec_get_offsets(rec, clust_index, NULL,
 						  ULINT_UNDEFINED, &row_heap);
 
diff -ruN innodb_plugin-1.0.6_orig/row/row0sel.c innodb_plugin-1.0.6_tmp/row/row0sel.c
--- innodb_plugin-1.0.6_orig/row/row0sel.c	2009-06-29 20:06:29.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/row/row0sel.c	2010-03-01 11:56:29.000000000 +0900
@@ -3766,6 +3766,13 @@
 	/* PHASE 4: Look for matching records in a loop */
 
 	rec = btr_pcur_get_rec(pcur);
+
+	if (srv_pass_corrupt_table && !rec) {
+		err = DB_CORRUPTION;
+		goto lock_wait_or_error;
+	}
+	ut_a(rec);
+
 	ut_ad(!!page_rec_is_comp(rec) == comp);
 #ifdef UNIV_SEARCH_DEBUG
 	/*
diff -ruN innodb_plugin-1.0.6_orig/srv/srv0srv.c innodb_plugin-1.0.6_tmp/srv/srv0srv.c
--- innodb_plugin-1.0.6_orig/srv/srv0srv.c	2010-03-01 11:55:53.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/srv/srv0srv.c	2010-03-01 11:56:29.000000000 +0900
@@ -406,6 +406,7 @@
 
 UNIV_INTERN ulint	srv_expand_import = 0; /* 0:disable 1:enable */
 UNIV_INTERN ulint	srv_relax_table_creation = 0; /* 0:disable 1:enable */
+UNIV_INTERN ulint	srv_pass_corrupt_table = 0; /* 0:disable 1:enable */
 
 UNIV_INTERN ulint	srv_extra_rsegments = 0; /* extra rseg for users */
 UNIV_INTERN ulint	srv_dict_size_limit = 0;
diff -ruN innodb_plugin-1.0.6_orig/srv/srv0start.c innodb_plugin-1.0.6_tmp/srv/srv0start.c
--- innodb_plugin-1.0.6_orig/srv/srv0start.c	2010-03-01 11:55:53.000000000 +0900
+++ innodb_plugin-1.0.6_tmp/srv/srv0start.c	2010-03-01 11:56:29.000000000 +0900
@@ -1809,6 +1809,13 @@
 
 	os_fast_mutex_free(&srv_os_test_mutex);
 
+	if (!srv_file_per_table_original_value
+	    && srv_pass_corrupt_table) {
+		fprintf(stderr, "InnoDB: Warning:"
+			" innodb_file_per_table is diabled."
+			" So innodb_pass_corrupt_table doesn't make sence\n");
+	}
+
 	if (srv_print_verbose_log) {
 		ut_print_timestamp(stderr);
 		fprintf(stderr,
