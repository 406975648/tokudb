diff -Nur a/patch_info/query_cache_with_comments.patch b/patch_info/query_cache_with_comments.patch
--- a/patch_info/query_cache_with_comments.patch	1970-01-01 03:00:00.000000000 +0300
+++ b/patch_info/query_cache_with_comments.patch	2010-07-07 03:33:07.498972002 +0400
@@ -0,0 +1,9 @@
+File=query_cache_with_comments.patch
+Name=Remove comments from query (need for cache hit)
+Version=1.0
+Author=Percona <info@percona.com>
+License=GPL
+Comment=
+Changelog
+2010-06-13
+Second version of patch
diff -Nur a/sql/mysqld.cc b/sql/mysqld.cc
--- a/sql/mysqld.cc	2010-07-07 03:33:06.988972002 +0400
+++ b/sql/mysqld.cc	2010-07-07 03:33:07.508972002 +0400
@@ -490,6 +490,7 @@
 my_bool opt_log_slow_slave_statements= 0;
 my_bool opt_log_slow_sp_statements= 0;
 my_bool opt_log_slow_timestamp_every= 0;
+my_bool opt_query_cache_strip_comments;
 my_bool opt_use_global_long_query_time= 0;
 my_bool opt_slow_query_log_microseconds_timestamp= 0;
 my_bool lower_case_file_system= 0;
@@ -5829,6 +5830,7 @@
   OPT_THREAD_STATISTICS,
   OPT_OPTIMIZER_FIX,
   OPT_SUPPRESS_LOG_WARNING_1592,
+  OPT_QUERY_CACHE_STRIP_COMMENTS,
   OPT_USE_GLOBAL_LONG_QUERY_TIME,
   OPT_USE_GLOBAL_LOG_SLOW_CONTROL,
   OPT_SLOW_QUERY_LOG_MICROSECONDS_TIMESTAMP,
@@ -6840,6 +6842,10 @@
   {"use_global_log_slow_control", OPT_USE_GLOBAL_LOG_SLOW_CONTROL,
     "Choose flags, wich always use the global variables. Multiple flags allowed in a comma-separated string. [none, log_slow_filter, log_slow_rate_limit, log_slow_verbosity, long_query_time, min_examined_row_limit, all]",
    0, 0, 0, GET_STR, NO_ARG, 0, 0, 0, SLOG_UG_NONE, 0, 0},
+  {"query_cache_strip_comments", OPT_QUERY_CACHE_STRIP_COMMENTS,
+   "Enable and disable optimisation \"strip comment for query cache\" - optimisation strip all comments from query while search query result in query cache",
+   (uchar**) &opt_query_cache_strip_comments, (uchar**) &opt_query_cache_strip_comments,
+   0, GET_BOOL, NO_ARG, 0, 0, 1, 0, 1, 0},
   {"use_global_long_query_time", OPT_USE_GLOBAL_LONG_QUERY_TIME,
    "Control always use global long_query_time or local long_query_time.",
    (uchar**) &opt_use_global_long_query_time, (uchar**) &opt_use_global_long_query_time,
diff -Nur a/sql/mysql_priv.h b/sql/mysql_priv.h
--- a/sql/mysql_priv.h	2010-07-07 03:33:06.998972002 +0400
+++ b/sql/mysql_priv.h	2010-07-07 03:33:07.508972002 +0400
@@ -2130,6 +2130,7 @@
 extern my_bool opt_log_slow_admin_statements, opt_log_slow_slave_statements;
 extern my_bool opt_log_slow_sp_statements;
 extern my_bool opt_log_slow_timestamp_every;
+extern my_bool opt_query_cache_strip_comments;
 extern my_bool opt_use_global_long_query_time;
 extern my_bool opt_slow_query_log_microseconds_timestamp;
 extern my_bool sp_automatic_privileges, opt_noacl;
diff -Nur a/sql/query_strip_comments.h b/sql/query_strip_comments.h
--- a/sql/query_strip_comments.h	1970-01-01 03:00:00.000000000 +0300
+++ b/sql/query_strip_comments.h	2010-07-07 03:33:07.518972002 +0400
@@ -0,0 +1,38 @@
+#ifndef _SQL_QUERY_STRIPC_COMMENTS_H_
+#define _SQL_QUERY_STRIPC_COMMENTS_H_
+#ifdef HAVE_QUERY_CACHE
+
+// implemented in sql_cache.cc
+class QueryStripComments
+{
+private:
+  QueryStripComments(const QueryStripComments&);
+  QueryStripComments& operator=(const QueryStripComments&);
+public:
+  QueryStripComments();
+  ~QueryStripComments();
+  void set(const char* a_query, uint a_query_length, uint a_additional_length);
+  
+  char* query()        { return buffer; }
+  uint  query_length() { return length; }
+private:
+  void cleanup();
+private:
+  char* buffer;
+  uint  length /*query length, not buffer length*/;
+  uint  buffer_length;
+  bool control;
+};
+class QueryStripComments_Backup
+{
+public:
+  QueryStripComments_Backup(THD* a_thd,QueryStripComments* qsc);
+  ~QueryStripComments_Backup();
+private:
+  THD*  thd;
+  char* query;
+  uint  length;
+};
+
+#endif // HAVE_QUERY_CACHE
+#endif // _SQL_QUERY_STRIPC_COMMENTS_H_
diff -Nur a/sql/set_var.cc b/sql/set_var.cc
--- a/sql/set_var.cc	2010-07-07 03:33:06.988972002 +0400
+++ b/sql/set_var.cc	2010-07-07 03:33:07.508972002 +0400
@@ -928,6 +928,8 @@
 #ifndef EMBEDDED_LIBRARY
 static sys_var_const_str_ptr    sys_repl_report_host(&vars, "report_host", &report_host);
 static sys_var_const_str_ptr    sys_repl_report_user(&vars, "report_user", &report_user);
+static sys_var_bool_ptr       sys_query_cache_strip_comments(&vars, "query_cache_strip_comments",
+                                                       &opt_query_cache_strip_comments);
 static sys_var_const_str_ptr    sys_repl_report_password(&vars, "report_password", &report_password);
 
 static uchar *slave_get_report_port(THD *thd)
diff -Nur a/sql/sql_cache.cc b/sql/sql_cache.cc
--- a/sql/sql_cache.cc	2010-07-07 03:33:06.988972002 +0400
+++ b/sql/sql_cache.cc	2010-07-07 03:33:07.508972002 +0400
@@ -333,6 +333,178 @@
 #include <hash.h>
 #include "../storage/myisammrg/ha_myisammrg.h"
 #include "../storage/myisammrg/myrg_def.h"
+#include "query_strip_comments.h"
+
+QueryStripComments::QueryStripComments()
+{
+  buffer = 0;
+  length = 0;
+  buffer_length = 0;
+  control = false;
+}
+QueryStripComments::~QueryStripComments()
+{
+  cleanup();
+}
+
+void QueryStripComments::set(const char* query, uint query_length, uint additional_length)
+{
+  if(false == opt_query_cache_strip_comments)
+    {
+      cleanup();
+      control = false;
+      buffer = (char*)query;
+      length = query_length;
+      return;
+    }
+  if(!control)
+    {
+      cleanup();
+      control = true;
+    }
+  {
+    uint new_buffer_length = query_length + additional_length;
+    if(new_buffer_length > buffer_length)
+      {
+	cleanup();
+	buffer = (char*)my_malloc(new_buffer_length,MYF(0));
+      }
+  }
+  uint query_position = 0;
+  uint position = 0;
+  int last_space = -1;
+  while(query_position < query_length)
+    {
+      char current = query[query_position];
+      switch(current)
+	{
+	case '\'':
+	  do
+	    {
+	      buffer[position] = query[query_position]; // copy current symbol
+	      ++position;
+	      ++query_position;
+	      if('\'' == query[query_position])
+		break;
+	    }
+	  while(query_position < query_length);
+	  break;
+	case '"':
+	  do
+	    {
+	      buffer[position] = query[query_position]; // copy current symbol
+	      ++position;
+	      ++query_position;
+	      if('"' == query[query_position])
+		break;
+	    }
+	  while(query_position < query_length);
+	  break;
+	case '/':
+	  if('*' == query[query_position+1])
+	    {
+	      query_position += 2; // skip "/*"
+	      do
+		{
+		  if('*' == query[query_position] && '/' == query[query_position+1]) // check for "*/"
+		    {
+		      query_position += 2; // skip "*/"
+		      break;
+		    }
+		  else
+		    {
+		      ++query_position;
+		    }
+		}
+	      while(query_position < query_length);
+	      continue; // analyze current symbol
+	    }
+	  break;
+	case '#':
+	  do
+	    {
+	      ++query_position; // skip current symbol
+	      if('\n' == query[query_position])  // check for '\n'
+		{
+		  ++query_position; // skip '\n'
+		  break;
+		}
+	    }
+	  while(query_position < query_length);
+	  continue; // analyze current symbol
+	case '-':
+	  if(query[query_position+1] == '-')
+	    {
+	      ++query_position; // skip "-"
+	      do
+		{
+		  ++query_position; // skip current symbol
+		  if('\n' == query[query_position]) // check for '\n'
+		    {
+		      ++query_position; // skip '\n'
+		      break;
+		    }
+		}
+	      while(query_position < query_length);
+	      continue; // analyze current symbol
+	    }
+	  break;
+	case '\r':
+	case '\n':
+	case ' ':
+	  if((last_space + 1) == position)
+	    {
+	      last_space = position;
+	      ++query_position; // skip double space
+	      continue;
+	    }
+	  else
+	    {
+	      last_space = position;
+	      break;
+	    }
+	break;
+	default:
+	  break; // make gcc happy
+	}
+      buffer[position] = current;
+      ++query_position;
+      ++position;
+    }
+    switch(buffer[position-1])
+      {
+      case ' ':
+      case '\r':
+      case '\n':
+	--position;
+      break;
+      default:
+	break; // make gcc happy
+      }
+    buffer[position] = 0;
+    length = position;
+}
+void QueryStripComments::cleanup()
+{
+  if(control && buffer)
+  {
+    my_free(buffer,MYF(0));
+  }
+  buffer        = 0;
+  length        = 0;
+  buffer_length = 0;
+}
+QueryStripComments_Backup::QueryStripComments_Backup(THD* a_thd,QueryStripComments* qsc)
+{
+  thd = a_thd;
+  query = thd->query();
+  length = thd->query_length();
+  thd->set_query(qsc->query(),qsc->query_length());
+}
+QueryStripComments_Backup::~QueryStripComments_Backup()
+{
+  thd->set_query(query,length);
+}
 
 #ifdef EMBEDDED_LIBRARY
 #include "emb_qcache.h"
@@ -1235,6 +1407,8 @@
       unlock();
       DBUG_VOID_RETURN;
     }
+    QueryStripComments *query_strip_comments = &(thd->query_strip_comments);
+    QueryStripComments_Backup backup(thd,query_strip_comments);
 
     /* Key is query + database + flag */
     if (thd->db_length)
@@ -1354,6 +1528,9 @@
   Query_cache_block_table *block_table, *block_table_end;
   ulong tot_length;
   Query_cache_query_flags flags;
+  QueryStripComments *query_strip_comments = &(thd->query_strip_comments);
+  char *sql_backup          = sql;
+  uint  query_length_backup = query_length;
   DBUG_ENTER("Query_cache::send_result_to_client");
 
   /*
@@ -1430,6 +1607,9 @@
   DBUG_ASSERT(thd->net.query_cache_query == 0);
 
   Query_cache_block *query_block;
+  query_strip_comments->set(sql, query_length, thd->db_length + 1 + QUERY_CACHE_FLAGS_SIZE);
+  sql          = query_strip_comments->query();
+  query_length = query_strip_comments->query_length();
 
   tot_length= query_length + thd->db_length + 1 + QUERY_CACHE_FLAGS_SIZE;
   if (thd->db_length)
@@ -1496,6 +1676,8 @@
 	 (uchar*) &flags, QUERY_CACHE_FLAGS_SIZE);
   query_block = (Query_cache_block *)  hash_search(&queries, (uchar*) sql,
 						   tot_length);
+  sql          = sql_backup;
+  query_length = query_length_backup;
   /* Quick abort on unlocked data */
   if (query_block == 0 ||
       query_block->query()->result() == 0 ||
diff -Nur a/sql/sql_class.h b/sql/sql_class.h
--- a/sql/sql_class.h	2010-07-07 03:33:06.988972002 +0400
+++ b/sql/sql_class.h	2010-07-07 03:33:07.518972002 +0400
@@ -22,7 +22,9 @@
 
 #include "log.h"
 #include "rpl_tblmap.h"
-
+#ifdef HAVE_QUERY_CACHE
+#include "query_strip_comments.h"
+#endif // HAVE_QUERY_CACHE
 /**
   An interface that is used to take an action when
   the locking module notices that a table version has changed
@@ -663,6 +665,9 @@
   */
   LEX_STRING query_string;
   Server_side_cursor *cursor;
+#ifdef HAVE_QUERY_CACHE
+  QueryStripComments query_strip_comments; // see sql_cache.cc
+#endif //HAVE_QUERY_CACHE
 
   inline char *query() { return query_string.str; }
   inline uint32 query_length() { return query_string.length; }
